---
import IconRetour from "../../assets/icones/retour.webp";
import IconDezoom from "../../assets/icones/dezoom.webp";
import IconEnveloppe from "../../assets/icones/enveloppe.svg";
import FormeBouton from "../../assets/icones/forme_main_bouton.svg";

export interface Props {
  type: "retour" | "contact" | "presentation" | "dezoom";
  size?: "mobile" | "tablet" | "desktop" | "footer";
  href?: string;
  onClick?: () => void;
  id?: string;
  strokeColor?: string;
  neonColor?: string;
}

const {
  type,
  size = "desktop",
  href = "#",
  onClick,
  id,
  strokeColor,
  neonColor = "var(--color-light-blue)",
} = Astro.props;

const icons = {
  retour: IconRetour,
  contact: IconEnveloppe,
  dezoom: IconDezoom,
  presentation: null, // On le fera plus tard
};

// Tailles dynamiques
const sizes = {
  mobile: {
    button: "w-[clamp(4.5rem,20vw,6.5rem)] h-[clamp(4.5rem,20vw,6.5rem)]",
    shape: "w-[clamp(1.8rem,8vw,2.6rem)] h-[clamp(1.8rem,8vw,2.6rem)]",
    icon: "w-[clamp(1.8rem,8vw,2.6rem)] h-[clamp(1.8rem,8vw,2.6rem)]",
    iconRetour: "w-[clamp(1.8rem,8vw,2.6rem)] h-[clamp(1.35rem,6vw,2rem)]",
    text: "text-sm",
  },
  tablet: {
    button: "w-[70px] h-[70px]",
    shape: "w-8 h-8",
    icon: "w-6 h-6",
    iconRetour: "w-8 h-6",
    text: "text-xs",
  },
  laptop: {
    button: "w-[85px] h-[85px]",
    shape: "w-9 h-9",
    icon: "w-7 h-7",
    iconRetour: "w-9 h-7",
    text: "text-sm",
  },
  desktop: {
    button: "w-[130px] h-[130px]",
    shape: "w-14 h-14",
    icon: "w-10 h-10",
    iconRetour: "w-[60px] h-[42px]",
    text: "text-xs",
  },
  footer: {
    button: "main-button-footer",
    shape: "main-button-shape-footer",
    icon: "main-button-icon-footer",
    iconRetour: "main-button-icon-retour-footer",
    text: "text-sm",
  },
};

const currentSize = sizes[size] || sizes.desktop;
---

<button
  class={`relative cursor-pointer transition-transform duration-200 ease-in-out border-none bg-none p-0 hover:scale-105 ${currentSize.button}`}
  data-main-button
  data-type={type}
  id={id ||
    (type === "contact"
      ? "contact-button"
      : type === "retour"
        ? "cv-return-button"
        : undefined)}
  data-onclick={onClick ? "true" : undefined}
  aria-label={type === "contact" ? "Ouvrir le formulaire de contact" : type === "retour" ? "Retour" : type === "presentation" ? "Ouvrir la présentation" : "Dézoomer"}
>
  <div
    class="w-full h-full rounded-full relative overflow-hidden flex items-center justify-center wii-main-button__circle"
    style={`--neon-color: ${neonColor};${strokeColor ? ` border-color: ${strokeColor};` : ""}`}
  >
    {/* Forme décorative en arrière-plan */}
    <div
      class={`absolute top-1 left-1 wii-main-button__shape ${currentSize.shape}`}
    >
      <FormeBouton class="w-full h-full" />
    </div>

    {/* Icônes */}
    {
      type === "retour" && (
        <img
          src="/icones/retour.webp"
          class={`wii-main-button__icon relative z-10 ${currentSize.iconRetour}`}
          alt="Retour"
        />
      )
    }
    {
      type === "contact" && (
        <IconEnveloppe
          class={`wii-main-button__icon relative z-10 ${currentSize.icon}`}
        />
      )
    }
    {
      type === "dezoom" && (
        <img
          src="/icones/dezoom.webp"
          class={`wii-main-button__icon relative z-10 ${currentSize.icon}`}
          alt="Dézoom"
        />
      )
    }
    {
      type === "presentation" && (
        <div
          id="mii-button-container"
          class="relative z-10 rounded-full overflow-hidden"
          style="width: 100%; height: 100%;"
        >
        </div>
      )
    }
  </div>
</button>

<style>
  /* Tailles fluides pour le footer */
  .main-button-footer {
    width: clamp(5.5rem, 8vw, 10.5rem);
    height: clamp(5.5rem, 8vw, 10.5rem);
  }
  
  .main-button-shape-footer {
    width: clamp(3rem, 4.5vw, 5rem);
    height: clamp(3rem, 4.5vw, 5rem);
  }
  
  .main-button-icon-footer {
    width: clamp(3rem, 5vw, 5.9375rem);
    height: clamp(2.25rem, 3.5vw, 4.0625rem);
  }
  
  .main-button-icon-retour-footer {
    width: clamp(3rem, 4.5vw, 5rem);
    height: clamp(2.25rem, 3.2vw, 3.5rem);
  }
  
  /* Focus ring supprimé */
  button:focus {
    outline: none;
    box-shadow: none;
  }

  .wii-main-button__circle {
    /* État normal */
    background-color: var(--color-light-gray); /* Couleur du Figma */
    border-color: var(--neon-color, var(--color-light-blue));
    border-width: 3px;
    border-style: solid;

    /* Ombres du Figma + effet néon ultra léger permanent */
    box-shadow:
      inset -4px -4px 9.5px rgba(0, 0, 0, 0.26),
      5.8px 8.7px 0px rgba(186, 188, 193, 1);
    
    transition: box-shadow 0.3s ease-out;
  }

  /* Animation de pulsation subtile sur le néon uniquement */
  .wii-main-button__circle::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    animation: button-glow-pulse 3s ease-in-out infinite;
  }

  .wii-main-button__icon {
    color: var(--color-dark-gray); /* Couleur grise du Figma */
  }

  .wii-main-button__shape {
    z-index: 1; /* Derrière l'icône */
    color: #ecebeb; /* Couleur bleue Wii */
  }

  /* État actif */
  button:active .wii-main-button__circle {
    transform: translateY(1px);
    box-shadow:
      inset -4px -4px 9.5px rgba(0, 0, 0, 0.26),
      4.8px 7.7px 0px rgba(186, 188, 193, 1);
  }
</style>

<script>
  const miiButtonInstances = new Map();
  let MiiButtonClass: any = null;

  async function loadMiiButton() {
    if (!MiiButtonClass) {
      const module = await import('../../scripts/mii-button');
      MiiButtonClass = module.MiiButton;
    }
    return MiiButtonClass;
  }
  
  async function initMiiButton() {
    // Lazy load MiiButton class
    const MiiButton = await loadMiiButton();
    
    // Initialiser le Mii 3D dans les boutons de présentation
    const presentationButtons = document.querySelectorAll('[data-type="presentation"]');
    
    presentationButtons.forEach((button, index) => {
      const container = button.querySelector('#mii-button-container');
      
      if (container && !miiButtonInstances.has(container)) {
        try {
          const instance = new MiiButton(container);
          miiButtonInstances.set(container, instance);
        } catch (error) {
          // Silencieux en prod
        }
      }
    });
  }
  
  document.addEventListener("DOMContentLoaded", () => {
    const buttons = document.querySelectorAll('button[data-onclick="true"]');

    buttons.forEach((button) => {
      button.addEventListener("click", (e) => {
        const type = button.getAttribute("data-type");
        // Actions gérées par les overlays
      });
    });

    // Initialiser le Mii uniquement lors d'une interaction ou quand le navigateur est idle
    // Cela évite de charger Three.js (132 KB) dans le chemin critique
    let miiInitialized = false;
    
    function initMiiButtonOnce() {
      if (!miiInitialized) {
        miiInitialized = true;
        initMiiButton();
      }
    }
    
    // Initialiser au hover du bouton présentation (priorité)
    const presentationButtons = document.querySelectorAll('[data-type="presentation"]');
    presentationButtons.forEach(btn => {
      btn.addEventListener('mouseenter', initMiiButtonOnce, { once: true });
      btn.addEventListener('focus', initMiiButtonOnce, { once: true });
    });
    
    // Différer le chargement 3D après le load complet pour améliorer LCP
    window.addEventListener('load', () => {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(initMiiButtonOnce, { timeout: 5000 });
      } else {
        setTimeout(initMiiButtonOnce, 3000);
      }
    });

    // Applique les effets néon avec la couleur personnalisée
    // Utiliser requestAnimationFrame pour éviter les forced reflow
    requestAnimationFrame(() => {
      // Batch toutes les lectures géométriques d'abord
      const circles = Array.from(document.querySelectorAll('.wii-main-button__circle'));
      const circleData = circles.map(circle => ({
        element: circle,
        neonColor: getComputedStyle(circle).getPropertyValue('--neon-color').trim(),
        parent: circle.closest('button')
      }));
      
      // Séparer les écritures dans un RAF séparé
      requestAnimationFrame(() => {
        circleData.forEach(({ element: circle, neonColor, parent }) => {
          if (neonColor && !neonColor.includes('--color-light-blue')) {
            // Créer une keyframe dynamique pour cette couleur
            const styleSheet = document.styleSheets[0];
            const keyframeName = `button-glow-pulse-${Math.random().toString(36).substr(2, 9)}`;
            
            const keyframes = `
              @keyframes ${keyframeName} {
                0%, 100% {
                  box-shadow: 0 0 2px ${neonColor}, 0 0 4px ${neonColor};
                }
                50% {
                  box-shadow: 0 0 4px ${neonColor}, 0 0 8px ${neonColor};
                }
              }
            `;
            
            try {
              styleSheet.insertRule(keyframes, styleSheet.cssRules.length);
              (circle as HTMLElement).style.setProperty('animation-name', keyframeName);
              
              // Applique aussi le hover dynamique
              if (parent) {
                parent.addEventListener('mouseenter', () => {
                  requestAnimationFrame(() => {
                    (circle as HTMLElement).style.boxShadow = `inset -4px -4px 9.5px rgba(0, 0, 0, 0.26), 5.8px 8.7px 0px rgba(186, 188, 193, 1), 0 0 6px ${neonColor}, 0 0 12px ${neonColor}`;
                  });
                });
                parent.addEventListener('mouseleave', () => {
                  requestAnimationFrame(() => {
                    (circle as HTMLElement).style.boxShadow = '';
                  });
                });
              }
            } catch (e) {
              console.warn('Could not create dynamic keyframe:', e);
            }
          }
        });
      });
    });
  });
  
  // Réinitialiser après les transitions Astro (navigation de page)
  document.addEventListener("astro:page-load", () => {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => initMiiButton(), { timeout: 2000 });
    } else {
      setTimeout(initMiiButton, 1000);
    }
  });
  
  // Réinitialiser avant les transitions Astro
  document.addEventListener("astro:before-swap", () => {
    miiButtonInstances.forEach(instance => {
      instance.destroy();
    });
    miiButtonInstances.clear();
  });
  
  // Observer les overlays pour réinitialiser le Mii après fermeture
  const observeOverlays = () => {
    const overlays = document.querySelectorAll('[id$="-overlay"]');
    overlays.forEach((overlay) => {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'class') {
            const classList = (mutation.target as HTMLElement).classList;
            // Si l'overlay est fermé (n'a plus la classe 'open')
            if (!classList.contains('open') && miiButtonInstances.size > 0) {
              // Réinitialiser le Mii après un court délai
              setTimeout(initMiiButton, 200);
            }
          }
        });
      });
      
      observer.observe(overlay, {
        attributes: true,
        attributeFilter: ['class']
      });
    });
  };
  
  // Lancer l'observation après le chargement
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(observeOverlays, 500);
  });
</script>
